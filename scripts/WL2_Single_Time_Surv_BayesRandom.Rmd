---
title: "WL2_Single_Time_Surv"
author: "Brandie QC"
date: "`r Sys.Date()`"
output: 
  html_document: 
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Analysis of Survival at WL2 2024 Garden to Plant for BC2 crosses

To Do:
-   See Julin's code for poperly calculating sem for surv

## Relevant Libraries and Functions
```{r}
library(tidyverse)
#library(tidymodels)
#library(lmerTest) #for mixed effect models
#conflicted::conflicts_prefer(lmerTest::lmer)
#library(broom.mixed) #tidy method for lmerTest
#library(emmeans) #for post-hoc pairwise comparisons 
#library(naniar) #replaces values with NA
#tidymodels_prefer()
library(brms)

elev_three_palette <- c("#0043F0", "#C9727F", "#F5A540") #colors from Gremer et al 2019
elev_order <- c("High", "Mid", "Low") #for proper arrangement in figures 
```

## Load pop and location data
```{r}
plant_info <- read_csv("../input/WL2_2024_Data/WL2_Final_2023_2024_Pop_Loc_Info.csv")
head(plant_info)
unique(plant_info$Pop.Type) #info about whether the plant is from 2023, an F1, F2, or parent 
unique(plant_info$status) #status info for planting (i.e. available spot to plant or not)
plant_info_to_merge <- plant_info %>% 
  select(Pop.Type, block, parent.pop=pop,mf:unique.ID) %>% 
  filter(!is.na(parent.pop))

pop_loc <- read_csv("../input/Strep_tort_locs.csv")
head(pop_loc)

unique(pop_loc$`Site code`)
unique(plant_info_to_merge$parent.pop)
#need to change YOSE to YO
pop_loc_yo <- pop_loc %>% mutate(parent.pop = str_replace(`Site code`, "YOSE(\\d+)", "YO\\1")) %>% select(Lat, Long, elev_m=`Elevation (m)`, parent.pop)
unique(pop_loc_yo$parent.pop)

pop_elev <- left_join(plant_info_to_merge, pop_loc_yo)
head(pop_elev)
```

## Load the mort/pheno data
```{r}
mort_pheno_1023 <- read_csv("../input/WL2_2024_Data/CorrectedCSVs/WL2_mort_pheno_20241023_corrected.csv", 
                            na = c("", "NA", "-", "N/A")) %>% arrange(death.date)
head(mort_pheno_1023)
names(mort_pheno_1023)
unique(mort_pheno_1023$bed) #D and "D."
unique(mort_pheno_1023$death.date)  
#some dates should be checked: 6/24, 6/27 - both were data verifcation errors, corrected on csv. 

mort_pheno_1023_nobuff <- mort_pheno_1023 %>% 
  filter(unique.ID !="buffer") %>% 
  filter(!is.na(unique.ID))
```

## Merge with location info 
```{r}
oct_mort_loc <- left_join(mort_pheno_1023_nobuff, pop_elev) 
head(oct_mort_loc)
names(oct_mort_loc)

oct_mort_loc %>% filter(!is.na(missing.date)) #11 2024 plants with a missing date & 1 2023 plant that went missing 
oct_mort_loc %>% filter(Pop.Type=="2023-survivor") # double checked none of these plants were actually alive (no data)
```

## Survival 

### Add Surv columns 
```{r}
wl2_surv <- oct_mort_loc %>% 
  filter(Pop.Type != "2023-TM2-fruit") %>% #take out 2023 fruiting locations 
  filter(is.na(missing.date)) %>% #take out plants that went missing 
  mutate(Surv_to_Oct = if_else(is.na(death.date), 1, 0), #surv to end of 2024 survey season
         Surv_Post_Transplant = if_else(is.na(death.date), 1,
           if_else(death.date=="6/18/24" | death.date=="6/25/24", 0, 1))) %>% #surv 2 weeks post-transplant
  select(Lat:elev_m, Pop.Type:rep, block:unique.ID, death.date, Surv_to_Oct, Surv_Post_Transplant, missing.date, survey.notes)

head(wl2_surv)
tail(wl2_surv)
```

## F1s

```{r}
wl2_surv_F1 <- wl2_surv %>% 
  filter(Pop.Type=="F1") %>% 
  unite(Field_Loc, bed:col, sep="_") %>% 
  select(Pop.Type:parent.pop, Field_Loc, unique.ID:Surv_Post_Transplant, survey.notes) %>% 
  separate_wider_delim(parent.pop, " x ", names = c("maternal.pop", "paternal.pop"), cols_remove = FALSE) %>% 
  mutate(WL2.cross = if_else(maternal.pop=="WL2" | paternal.pop=="WL2", TRUE, FALSE))
wl2_surv_F1
xtabs(~Surv_to_Oct+WL2.cross, data=wl2_surv_F1) #slightly higher surv in WL2 crosses 
xtabs(~Surv_Post_Transplant+WL2.cross, data=wl2_surv_F1) #slightly higher surv in TM2 crosses
```

### Calculate Yes/No Parents
```{r}
wl2_surv_F1_binary <- wl2_surv_F1 %>% 
 # filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  mutate(WL2=if_else(str_detect(parent.pop, "WL2"), 1, 0),
         CC=if_else(str_detect(parent.pop, "CC"), 1, 0),
         BH=if_else(str_detect(parent.pop, "BH"), 1, 0),
         WV=if_else(str_detect(parent.pop, "WV"), 1, 0),
         LV1=if_else(str_detect(parent.pop, "LV1"), 1, 0),
         TM2=if_else(str_detect(parent.pop, "TM2"), 1, 0),
         SQ3=if_else(str_detect(parent.pop, "SQ3"), 1, 0),
         DPR=if_else(str_detect(parent.pop, "DPR"), 1, 0),
         YO11=if_else(str_detect(parent.pop, "YO11"), 1, 0))
head(wl2_surv_F1_binary, 20)
summary(wl2_surv_F1_binary)
#switch to long format?
#could try switching to character?

xtabs(~Surv_to_Oct+WL2, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+CC, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+BH, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+WV, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+LV1, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+TM2, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+SQ3, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+DPR, data=wl2_surv_F1_binary)
xtabs(~Surv_to_Oct+YO11, data=wl2_surv_F1_binary)
```

### Plot the data
```{r}
wl2_surv_F1_binary_long <- wl2_surv_F1_binary %>% 
  pivot_longer(WL2:YO11, names_to = "pop", values_to = "Presence")
head(wl2_surv_F1_binary_long, 15)

wl2_surv_F1_binary_long_means <- wl2_surv_F1_binary_long %>% 
  group_by(WL2.cross, pop, Presence) %>% 
  summarise(N_Surv = sum(!is.na(Surv_to_Oct)), 
            mean_Surv_to_Oct = mean(Surv_to_Oct,na.rm=(TRUE)), 
            mean_Surv_Post_Transplant = mean(Surv_Post_Transplant,na.rm=(TRUE)))
wl2_surv_F1_binary_long_means

wl2_surv_F1_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Presence, y=mean_Surv_to_Oct, fill=Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  #ylim(-0.05, 0.3) +
  labs(title="Survival to October - WL2 F1s") +
  #theme_classic() +
  facet_wrap(~pop)

wl2_surv_F1_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Presence, y=mean_Surv_Post_Transplant, fill=Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  labs(title="Survival to Two Weeks Post-Transplant  - WL2 F1s") +
  #theme_classic() +
  facet_wrap(~pop)
```


### Bayesian random
Filter to WL2 F1s Only 
Logit scale reminder: logit(x) = ln(x / (1-x));
```{r}
wl2_surv_wl2F1s <- wl2_surv_F1_binary %>% filter(WL2.cross=="TRUE")  
summary(wl2_surv_wl2F1s)

xtabs(~Surv_to_Oct+CC, data=wl2_surv_wl2F1s) #no CC x WL2 or vice versa 
xtabs(~Surv_to_Oct+BH, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+WV, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+LV1, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+TM2, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+SQ3, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+DPR, data=wl2_surv_wl2F1s)
xtabs(~Surv_to_Oct+YO11, data=wl2_surv_wl2F1s) #no YO11 x WL2 or vice versa 
```


```{r}
surv_parent_binary_bf1 <- brmsformula(Surv_to_Oct ~ (1|BH)+(1|WV)+(1|LV1)+(1|TM2)+(1|SQ3)+(1|DPR))

get_prior(surv_parent_binary_bf1, family = "bernoulli", data = wl2_surv_wl2F1s)
prior1 <- c(set_prior(prior = 'normal(0, 5)', class='Intercept'),
            set_prior(prior = 'normal(0, 5)', class='sd'))
```

```{r}
surv_parent_binary_m1 <- brm(surv_parent_binary_bf1, 
                             family = "bernoulli",
                             data = wl2_surv_wl2F1s,
                             cores=4,
                             iter = 4000, #increased iterations b/c complex model
                             control = list(adapt_delta = 0.9),
                             prior=prior1) #increased adapt_delta to help with divergent transitions
```


```{r}
prior_summary(surv_parent_binary_m1)
summary(surv_parent_binary_m1)
#Rhat <1.05 (good!)
#ESS > 1000 (good!)
```

```{r}
plot(surv_parent_binary_m1,  nvariables = 3, ask=FALSE) #plots look a little better with prior distribution adjustments 

#pairs(surv_parent_binary_m1)

pp_check(surv_parent_binary_m1)  # posterior predictive checks
#The main use of this function is to check if you model predicts your data accurately (using the estimates). If it does, then you can use that model to generate new data and make accurate predictions.
#light blue = 10 random draws or distributions created by the model
#dark blue = posterior distribution
```

To calcualte the stats we need to extract the posterior samples, and add the Intercept to each pop random effect, and then compute the stats.

```{r}
intercept <- as_draws_df(surv_parent_binary_m1, variable = "b_Intercept") %>% as_tibble() %>% select(starts_with("b"))

r_pops <- as_draws_df(surv_parent_binary_m1, variable = "*r_", regex = TRUE) %>% as_tibble() %>% select(starts_with("r"))

r_pops <- r_pops %>% mutate(across(everything(), ~ .x + intercept$b_Intercept))
```


```{r}
posterior::summarize_draws(r_pops) %>%
  mutate(across(mean:q95, inv_logit_scaled))
#estimates seem to be a little off...
```

## F2s

```{r}
wl2_surv_F2 <- wl2_surv %>% 
  filter(Pop.Type=="F2") %>% 
  unite(Field_Loc, bed:col, sep="_") %>% 
  mutate(WL2.cross = if_else(str_detect(parent.pop, "WL2"), TRUE, FALSE)) %>% 
  select(WL2.cross, Pop.Type:parent.pop, Field_Loc, unique.ID:Surv_Post_Transplant, survey.notes) %>% 
  separate_wider_delim(parent.pop, ") x (", names = c("maternal.pops", "paternal.pops"), cols_remove = FALSE) %>%
  mutate(maternal.pops=str_remove(maternal.pops, "\\("), paternal.pops=str_remove(paternal.pops, "\\)")) 
wl2_surv_F2
```

### Calculate yes/no for each parent 
```{r}
wl2_surv_F2_binary <- wl2_surv_F2 %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  mutate(WL2=if_else(str_detect(parent.pop, "WL2"), 1, 0),
         CC=if_else(str_detect(parent.pop, "CC"), 1, 0),
         BH=if_else(str_detect(parent.pop, "BH"), 1, 0),
         WV=if_else(str_detect(parent.pop, "WV"), 1, 0),
         LV1=if_else(str_detect(parent.pop, "LV1"), 1, 0),
         TM2=if_else(str_detect(parent.pop, "TM2"), 1, 0),
         SQ3=if_else(str_detect(parent.pop, "SQ3"), 1, 0),
         DPR=if_else(str_detect(parent.pop, "DPR"), 1, 0),
         YO11=if_else(str_detect(parent.pop, "YO11"), 1, 0),
         maternal.WL2=if_else(str_detect(maternal.pops, "WL2"), 1, 0),
         maternal.CC=if_else(str_detect(maternal.pops, "CC"), 1, 0),
         maternal.BH=if_else(str_detect(maternal.pops, "BH"), 1, 0),
         maternal.WV=if_else(str_detect(maternal.pops, "WV"), 1, 0),
         maternal.LV1=if_else(str_detect(maternal.pops, "LV1"), 1, 0),
         maternal.TM2=if_else(str_detect(maternal.pops, "TM2"), 1, 0),
         maternal.SQ3=if_else(str_detect(maternal.pops, "SQ3"), 1, 0),
         maternal.DPR=if_else(str_detect(maternal.pops, "DPR"), 1, 0),
         maternal.YO11=if_else(str_detect(maternal.pops, "YO11"), 1, 0))
head(wl2_surv_F2_binary, 20)
summary(wl2_surv_F2_binary)

xtabs(~Surv_to_Oct+WL2, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+CC, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+BH, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+WV, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+LV1, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+TM2, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+SQ3, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+DPR, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+YO11, data=wl2_surv_F2_binary)

xtabs(~Surv_to_Oct+WL2, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+CC, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+BH, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+WV, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+LV1, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+TM2, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+SQ3, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+DPR, data=wl2_surv_F2_binary)
xtabs(~Surv_to_Oct+YO11, data=wl2_surv_F2_binary)
```

### Plot the data
```{r}
wl2_surv_F2_binary_long <- wl2_surv_F2_binary %>% 
  select(WL2.cross:YO11) %>% 
  pivot_longer(WL2:YO11, names_to = "pop", values_to = "Presence")
  #pivot_longer(maternal.WL2:maternal.YO11, names_to = "maternal_pop", values_to = "Maternal_Presence") 
head(wl2_surv_F2_binary_long, 15)

wl2_surv_F2_binary_long_means <- wl2_surv_F2_binary_long %>% 
  group_by(WL2.cross, pop, Presence) %>% 
  summarise(N_Surv = sum(!is.na(Surv_to_Oct)), 
            mean_Surv_to_Oct = mean(Surv_to_Oct,na.rm=(TRUE)), 
            mean_Surv_Post_Transplant = mean(Surv_Post_Transplant,na.rm=(TRUE)))
wl2_surv_F2_binary_long_means

wl2_surv_F2_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Presence, y=mean_Surv_to_Oct, fill=Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  #ylim(-0.05, 0.3) +
  labs(title="Survival to October - WL2 F2s") +
  #theme_classic() +
  facet_wrap(~pop)

wl2_surv_F2_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Presence, y=mean_Surv_Post_Transplant, fill=Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  labs(title="Survival to Two Weeks Post-Transplant  - WL2 F2s") +
  #theme_classic() +
  facet_wrap(~pop)
```

### Bayesian random
```{r}
surv_parent_binary_bf2 <- brmsformula(Surv_to_Oct ~ (1|BH)+(1|CC)+(1|DPR)+(1|LV1)+(1|SQ3)+(1|TM2)+(1|WV)+(1|YO11))

get_prior(surv_parent_binary_bf2, family = "bernoulli", data = wl2_surv_F2_binary)
```

```{r}
surv_parent_binary_m2 <- brm(surv_parent_binary_bf2, 
                             family = "bernoulli",
                             data = wl2_surv_F2_binary,
                             cores=4,
                             iter = 4000, #increased iterations b/c complex model
                             control = list(adapt_delta = 0.9),
                             prior=prior1) #increased adapt_delta to help with divergent transitions
#Warning: There were 28 divergent transitions after warmup.
```

```{r}
prior_summary(surv_parent_binary_m2)
summary(surv_parent_binary_m2)
#Rhat <1.05 (good!)
#ESS > 1000 (good!)
```

```{r}
plot(surv_parent_binary_m2,  nvariables = 3, ask=FALSE) #plots don't look good 

#pairs(surv_parent_binary_m2)

pp_check(surv_parent_binary_m1)  # posterior predictive checks
#some draws differ from posterior distribution 
```

To calcualte the stats we need to extract the posterior samples, and add the Intercept to each pop random effect, and then compute the stats.

```{r}
intercept <- as_draws_df(surv_parent_binary_m2, variable = "b_Intercept") %>% as_tibble() %>% select(starts_with("b"))

r_pops <- as_draws_df(surv_parent_binary_m2, variable = "*r_", regex = TRUE) %>% as_tibble() %>% select(starts_with("r"))

r_pops <- r_pops %>% mutate(across(everything(), ~ .x + intercept$b_Intercept))
```

```{r}
posterior::summarize_draws(r_pops) %>%
  mutate(across(mean:q95, inv_logit_scaled))
#estimates seem to be a little off...
```

### MATERNAL POPS - Plot
```{r}
wl2_surv_F2_MAT_binary_long <- wl2_surv_F2_binary %>% 
  select(WL2.cross:survey.notes, maternal.WL2:maternal.YO11) %>% 
  pivot_longer(maternal.WL2:maternal.YO11, names_to = "maternal_pop", values_to = "Maternal_Presence") 
head(wl2_surv_F2_MAT_binary_long, 15)

wl2_surv_F2_MAT_binary_long_means <- wl2_surv_F2_MAT_binary_long %>% 
  group_by(WL2.cross, maternal_pop, Maternal_Presence) %>% 
  summarise(N_Surv = sum(!is.na(Surv_to_Oct)), 
            mean_Surv_to_Oct = mean(Surv_to_Oct,na.rm=(TRUE)), 
            mean_Surv_Post_Transplant = mean(Surv_Post_Transplant,na.rm=(TRUE)))
wl2_surv_F2_MAT_binary_long_means

wl2_surv_F2_MAT_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Maternal_Presence, y=mean_Surv_to_Oct, fill=Maternal_Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  #ylim(-0.05, 0.3) +
  labs(title="Survival to October - WL2 F2ss - Maternal Pops") +
  #theme_classic() +
  facet_wrap(~maternal_pop)

wl2_surv_F2_MAT_binary_long_means %>% 
  filter(WL2.cross=="TRUE") %>% #if want TM2 F1s just # this out 
  ggplot(aes(x=Maternal_Presence, y=mean_Surv_Post_Transplant, fill=Maternal_Presence)) +
  geom_col(width = 0.7,position = position_dodge(0.75), colour="black") +
  labs(title="Survival to Two Weeks Post-Transplant  - WL2 F2s - Maternal Pops") +
  #theme_classic() +
  facet_wrap(~maternal_pop)
```

### Bayesian random - MATERNAL POPS
```{r}
surv_parent_binary_bf3 <- brmsformula(Surv_to_Oct ~ (1|maternal.BH)+(1|maternal.CC)+(1|maternal.DPR)+(1|maternal.LV1)+(1|maternal.SQ3)+(1|maternal.TM2)+(1|maternal.WV)+(1|maternal.YO11))

get_prior(surv_parent_binary_bf3, family = "bernoulli", data = wl2_surv_F2_binary)
```

```{r}
surv_parent_binary_m3 <- brm(surv_parent_binary_bf3, 
                             family = "bernoulli",
                             data = wl2_surv_F2_binary,
                             cores=4,
                             iter = 4000, #increased iterations b/c complex model
                             control = list(adapt_delta = 0.9),
                             prior = prior1) #increased adapt_delta to help with divergent transitions
#Warning: There were 37 divergent transitions after warmup. 
```

```{r}
prior_summary(surv_parent_binary_m3)

summary(surv_parent_binary_m3)
#Rhat <1.05 (good!)
#ESS > 1000 (good!)
```

```{r}
plot(surv_parent_binary_m3,  nvariables = 3, ask=FALSE) #plots don't look good 

#pairs(surv_parent_binary_m3)

pp_check(surv_parent_binary_m1)  # posterior predictive checks
```

To calcualte the stats we need to extract the posterior samples, and add the Intercept to each pop random effect, and then compute the stats.

```{r}
intercept <- as_draws_df(surv_parent_binary_m3, variable = "b_Intercept") %>% as_tibble() %>% select(starts_with("b"))

r_pops <- as_draws_df(surv_parent_binary_m3, variable = "*r_", regex = TRUE) %>% as_tibble() %>% select(starts_with("r"))

r_pops <- r_pops %>% mutate(across(everything(), ~ .x + intercept$b_Intercept))
```

```{r}
posterior::summarize_draws(r_pops) %>%
  mutate(across(mean:q95, inv_logit_scaled))
#estimates seem to be a little off...
```